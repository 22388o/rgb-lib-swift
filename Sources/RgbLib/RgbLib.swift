// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(rgb_libFFI)
import rgb_libFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_rgb_lib_53a0_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_rgb_lib_53a0_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
fileprivate class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> Array<UInt8> {
        let range = offset..<(offset+count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer({ buffer in
            data.copyBytes(to: buffer, from: range)
        })
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
fileprivate class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: Writer)
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    static func lift(_ buf: RustBuffer) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    static func lower(_ value: SwiftType) -> RustBuffer {
          let writer = Writer()
          write(value, into: writer)
          return RustBuffer(bytes: writer.bytes)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    static func read(from buf: Reader) throws -> UInt8 {
        return try lift(buf.readInt())
    }

    static func write(_ value: UInt8, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    static func read(from buf: Reader) throws -> UInt32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: Reader) throws -> UInt64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    static func read(from buf: Reader) throws -> Int64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: Int64, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: Reader) throws -> Bool {
        return try lift(buf.readInt())
    }

    static func write(_ value: Bool, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: Reader) throws -> String {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: Writer) {
        let len = Int32(value.utf8.count)
        buf.writeInt(len)
        buf.writeBytes(value.utf8)
    }
}


public protocol WalletProtocol {
    func blind(assetId: String?, durationSeconds: UInt32?) throws -> BlindData
    func createUtxos(online: Online) throws -> UInt64
    func createUtxosBegin(online: Online) throws -> String
    func createUtxosEnd(online: Online, signedPsbt: String) throws -> UInt64
    func deleteTransfers(blindedUtxo: String?) throws
    func drainTo(online: Online, address: String, destroyAssets: Bool) throws -> String
    func drainToBegin(online: Online, address: String, destroyAssets: Bool) throws -> String
    func drainToEnd(online: Online, signedPsbt: String) throws -> String
    func failTransfers(online: Online, blindedUtxo: String?) throws
    func getAddress()  -> String
    func getAssetBalance(assetId: String) throws -> Balance
    func goOnline(electrumUrl: String, skipConsistencyCheck: Bool) throws -> Online
    func issueAsset(online: Online, ticker: String, name: String, precision: UInt8, amount: UInt64) throws -> Asset
    func listAssets() throws -> [Asset]
    func listTransfers(assetId: String) throws -> [Transfer]
    func listUnspents(settledOnly: Bool) throws -> [Unspent]
    func refresh(online: Online, assetId: String?) throws
    func send(online: Online, assetId: String, blindedUtxo: String, amount: UInt64) throws -> String
    func sendBegin(online: Online, assetId: String, blindedUtxo: String, amount: UInt64) throws -> String
    func sendEnd(online: Online, signedPsbt: String) throws -> String
    
}

public class Wallet: WalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(walletData: WalletData) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    
    rgb_lib_53a0_Wallet_new(
        FfiConverterTypeWalletData.lower(walletData), $0)
})
    }

    deinit {
        try! rustCall { ffi_rgb_lib_53a0_Wallet_object_free(pointer, $0) }
    }

    

    
    public func blind(assetId: String?, durationSeconds: UInt32?) throws -> BlindData {
        return try FfiConverterTypeBlindData.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_blind(self.pointer, 
        FfiConverterOptionString.lower(assetId), 
        FfiConverterOptionUInt32.lower(durationSeconds), $0
    )
}
        )
    }
    public func createUtxos(online: Online) throws -> UInt64 {
        return try FfiConverterUInt64.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_create_utxos(self.pointer, 
        FfiConverterTypeOnline.lower(online), $0
    )
}
        )
    }
    public func createUtxosBegin(online: Online) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_create_utxos_begin(self.pointer, 
        FfiConverterTypeOnline.lower(online), $0
    )
}
        )
    }
    public func createUtxosEnd(online: Online, signedPsbt: String) throws -> UInt64 {
        return try FfiConverterUInt64.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_create_utxos_end(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(signedPsbt), $0
    )
}
        )
    }
    public func deleteTransfers(blindedUtxo: String?) throws {
        try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_delete_transfers(self.pointer, 
        FfiConverterOptionString.lower(blindedUtxo), $0
    )
}
    }
    public func drainTo(online: Online, address: String, destroyAssets: Bool) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_drain_to(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(address), 
        FfiConverterBool.lower(destroyAssets), $0
    )
}
        )
    }
    public func drainToBegin(online: Online, address: String, destroyAssets: Bool) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_drain_to_begin(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(address), 
        FfiConverterBool.lower(destroyAssets), $0
    )
}
        )
    }
    public func drainToEnd(online: Online, signedPsbt: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_drain_to_end(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(signedPsbt), $0
    )
}
        )
    }
    public func failTransfers(online: Online, blindedUtxo: String?) throws {
        try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_fail_transfers(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterOptionString.lower(blindedUtxo), $0
    )
}
    }
    public func getAddress()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    rgb_lib_53a0_Wallet_get_address(self.pointer, $0
    )
}
        )
    }
    public func getAssetBalance(assetId: String) throws -> Balance {
        return try FfiConverterTypeBalance.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_get_asset_balance(self.pointer, 
        FfiConverterString.lower(assetId), $0
    )
}
        )
    }
    public func goOnline(electrumUrl: String, skipConsistencyCheck: Bool) throws -> Online {
        return try FfiConverterTypeOnline.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_go_online(self.pointer, 
        FfiConverterString.lower(electrumUrl), 
        FfiConverterBool.lower(skipConsistencyCheck), $0
    )
}
        )
    }
    public func issueAsset(online: Online, ticker: String, name: String, precision: UInt8, amount: UInt64) throws -> Asset {
        return try FfiConverterTypeAsset.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_issue_asset(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(ticker), 
        FfiConverterString.lower(name), 
        FfiConverterUInt8.lower(precision), 
        FfiConverterUInt64.lower(amount), $0
    )
}
        )
    }
    public func listAssets() throws -> [Asset] {
        return try FfiConverterSequenceTypeAsset.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_list_assets(self.pointer, $0
    )
}
        )
    }
    public func listTransfers(assetId: String) throws -> [Transfer] {
        return try FfiConverterSequenceTypeTransfer.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_list_transfers(self.pointer, 
        FfiConverterString.lower(assetId), $0
    )
}
        )
    }
    public func listUnspents(settledOnly: Bool) throws -> [Unspent] {
        return try FfiConverterSequenceTypeUnspent.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_list_unspents(self.pointer, 
        FfiConverterBool.lower(settledOnly), $0
    )
}
        )
    }
    public func refresh(online: Online, assetId: String?) throws {
        try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_refresh(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterOptionString.lower(assetId), $0
    )
}
    }
    public func send(online: Online, assetId: String, blindedUtxo: String, amount: UInt64) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_send(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(assetId), 
        FfiConverterString.lower(blindedUtxo), 
        FfiConverterUInt64.lower(amount), $0
    )
}
        )
    }
    public func sendBegin(online: Online, assetId: String, blindedUtxo: String, amount: UInt64) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_send_begin(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(assetId), 
        FfiConverterString.lower(blindedUtxo), 
        FfiConverterUInt64.lower(amount), $0
    )
}
        )
    }
    public func sendEnd(online: Online, signedPsbt: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    rgb_lib_53a0_Wallet_send_end(self.pointer, 
        FfiConverterTypeOnline.lower(online), 
        FfiConverterString.lower(signedPsbt), $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    static func read(from buf: Reader) throws -> Wallet {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: Wallet, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct Asset {
    public var assetId: String
    public var ticker: String
    public var name: String
    public var precision: UInt8
    public var balance: Balance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetId: String, ticker: String, name: String, precision: UInt8, balance: Balance) {
        self.assetId = assetId
        self.ticker = ticker
        self.name = name
        self.precision = precision
        self.balance = balance
    }
}


extension Asset: Equatable, Hashable {
    public static func ==(lhs: Asset, rhs: Asset) -> Bool {
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.precision != rhs.precision {
            return false
        }
        if lhs.balance != rhs.balance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetId)
        hasher.combine(ticker)
        hasher.combine(name)
        hasher.combine(precision)
        hasher.combine(balance)
    }
}


fileprivate struct FfiConverterTypeAsset: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Asset {
        return try Asset(
            assetId: FfiConverterString.read(from: buf), 
            ticker: FfiConverterString.read(from: buf), 
            name: FfiConverterString.read(from: buf), 
            precision: FfiConverterUInt8.read(from: buf), 
            balance: FfiConverterTypeBalance.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Asset, into buf: Writer) {
        FfiConverterString.write(value.assetId, into: buf)
        FfiConverterString.write(value.ticker, into: buf)
        FfiConverterString.write(value.name, into: buf)
        FfiConverterUInt8.write(value.precision, into: buf)
        FfiConverterTypeBalance.write(value.balance, into: buf)
    }
}


public struct Balance {
    public var settled: UInt64
    public var future: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(settled: UInt64, future: UInt64) {
        self.settled = settled
        self.future = future
    }
}


extension Balance: Equatable, Hashable {
    public static func ==(lhs: Balance, rhs: Balance) -> Bool {
        if lhs.settled != rhs.settled {
            return false
        }
        if lhs.future != rhs.future {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(settled)
        hasher.combine(future)
    }
}


fileprivate struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Balance {
        return try Balance(
            settled: FfiConverterUInt64.read(from: buf), 
            future: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Balance, into buf: Writer) {
        FfiConverterUInt64.write(value.settled, into: buf)
        FfiConverterUInt64.write(value.future, into: buf)
    }
}


public struct BlindData {
    public var blindedUtxo: String
    public var blindingSecret: UInt64
    public var expirationTimestamp: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blindedUtxo: String, blindingSecret: UInt64, expirationTimestamp: Int64?) {
        self.blindedUtxo = blindedUtxo
        self.blindingSecret = blindingSecret
        self.expirationTimestamp = expirationTimestamp
    }
}


extension BlindData: Equatable, Hashable {
    public static func ==(lhs: BlindData, rhs: BlindData) -> Bool {
        if lhs.blindedUtxo != rhs.blindedUtxo {
            return false
        }
        if lhs.blindingSecret != rhs.blindingSecret {
            return false
        }
        if lhs.expirationTimestamp != rhs.expirationTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blindedUtxo)
        hasher.combine(blindingSecret)
        hasher.combine(expirationTimestamp)
    }
}


fileprivate struct FfiConverterTypeBlindData: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BlindData {
        return try BlindData(
            blindedUtxo: FfiConverterString.read(from: buf), 
            blindingSecret: FfiConverterUInt64.read(from: buf), 
            expirationTimestamp: FfiConverterOptionInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BlindData, into buf: Writer) {
        FfiConverterString.write(value.blindedUtxo, into: buf)
        FfiConverterUInt64.write(value.blindingSecret, into: buf)
        FfiConverterOptionInt64.write(value.expirationTimestamp, into: buf)
    }
}


public struct Keys {
    public var mnemonic: String
    public var xpub: String
    public var xpubFingerprint: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: String, xpub: String, xpubFingerprint: String) {
        self.mnemonic = mnemonic
        self.xpub = xpub
        self.xpubFingerprint = xpubFingerprint
    }
}


extension Keys: Equatable, Hashable {
    public static func ==(lhs: Keys, rhs: Keys) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.xpub != rhs.xpub {
            return false
        }
        if lhs.xpubFingerprint != rhs.xpubFingerprint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(xpub)
        hasher.combine(xpubFingerprint)
    }
}


fileprivate struct FfiConverterTypeKeys: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Keys {
        return try Keys(
            mnemonic: FfiConverterString.read(from: buf), 
            xpub: FfiConverterString.read(from: buf), 
            xpubFingerprint: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Keys, into buf: Writer) {
        FfiConverterString.write(value.mnemonic, into: buf)
        FfiConverterString.write(value.xpub, into: buf)
        FfiConverterString.write(value.xpubFingerprint, into: buf)
    }
}


public struct Online {
    public var id: UInt64
    public var electrumUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64, electrumUrl: String) {
        self.id = id
        self.electrumUrl = electrumUrl
    }
}


extension Online: Equatable, Hashable {
    public static func ==(lhs: Online, rhs: Online) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.electrumUrl != rhs.electrumUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(electrumUrl)
    }
}


fileprivate struct FfiConverterTypeOnline: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Online {
        return try Online(
            id: FfiConverterUInt64.read(from: buf), 
            electrumUrl: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Online, into buf: Writer) {
        FfiConverterUInt64.write(value.id, into: buf)
        FfiConverterString.write(value.electrumUrl, into: buf)
    }
}


public struct Outpoint {
    public var txid: String
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}


extension Outpoint: Equatable, Hashable {
    public static func ==(lhs: Outpoint, rhs: Outpoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}


fileprivate struct FfiConverterTypeOutpoint: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Outpoint {
        return try Outpoint(
            txid: FfiConverterString.read(from: buf), 
            vout: FfiConverterUInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Outpoint, into buf: Writer) {
        FfiConverterString.write(value.txid, into: buf)
        FfiConverterUInt32.write(value.vout, into: buf)
    }
}


public struct RgbAllocation {
    public var assetId: String?
    public var amount: UInt64
    public var settled: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(assetId: String?, amount: UInt64, settled: Bool) {
        self.assetId = assetId
        self.amount = amount
        self.settled = settled
    }
}


extension RgbAllocation: Equatable, Hashable {
    public static func ==(lhs: RgbAllocation, rhs: RgbAllocation) -> Bool {
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.settled != rhs.settled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(assetId)
        hasher.combine(amount)
        hasher.combine(settled)
    }
}


fileprivate struct FfiConverterTypeRgbAllocation: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> RgbAllocation {
        return try RgbAllocation(
            assetId: FfiConverterOptionString.read(from: buf), 
            amount: FfiConverterUInt64.read(from: buf), 
            settled: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: RgbAllocation, into buf: Writer) {
        FfiConverterOptionString.write(value.assetId, into: buf)
        FfiConverterUInt64.write(value.amount, into: buf)
        FfiConverterBool.write(value.settled, into: buf)
    }
}


public struct Transfer {
    public var idx: Int64
    public var createdAt: Int64
    public var updatedAt: Int64
    public var status: TransferStatus
    public var received: UInt64
    public var sent: UInt64
    public var txid: String?
    public var blindedUtxo: String?
    public var unblindedUtxo: Outpoint?
    public var changeUtxo: Outpoint?
    public var blindingSecret: UInt64?
    public var expiration: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idx: Int64, createdAt: Int64, updatedAt: Int64, status: TransferStatus, received: UInt64, sent: UInt64, txid: String?, blindedUtxo: String?, unblindedUtxo: Outpoint?, changeUtxo: Outpoint?, blindingSecret: UInt64?, expiration: Int64?) {
        self.idx = idx
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.status = status
        self.received = received
        self.sent = sent
        self.txid = txid
        self.blindedUtxo = blindedUtxo
        self.unblindedUtxo = unblindedUtxo
        self.changeUtxo = changeUtxo
        self.blindingSecret = blindingSecret
        self.expiration = expiration
    }
}


extension Transfer: Equatable, Hashable {
    public static func ==(lhs: Transfer, rhs: Transfer) -> Bool {
        if lhs.idx != rhs.idx {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.received != rhs.received {
            return false
        }
        if lhs.sent != rhs.sent {
            return false
        }
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.blindedUtxo != rhs.blindedUtxo {
            return false
        }
        if lhs.unblindedUtxo != rhs.unblindedUtxo {
            return false
        }
        if lhs.changeUtxo != rhs.changeUtxo {
            return false
        }
        if lhs.blindingSecret != rhs.blindingSecret {
            return false
        }
        if lhs.expiration != rhs.expiration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(idx)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(status)
        hasher.combine(received)
        hasher.combine(sent)
        hasher.combine(txid)
        hasher.combine(blindedUtxo)
        hasher.combine(unblindedUtxo)
        hasher.combine(changeUtxo)
        hasher.combine(blindingSecret)
        hasher.combine(expiration)
    }
}


fileprivate struct FfiConverterTypeTransfer: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Transfer {
        return try Transfer(
            idx: FfiConverterInt64.read(from: buf), 
            createdAt: FfiConverterInt64.read(from: buf), 
            updatedAt: FfiConverterInt64.read(from: buf), 
            status: FfiConverterTypeTransferStatus.read(from: buf), 
            received: FfiConverterUInt64.read(from: buf), 
            sent: FfiConverterUInt64.read(from: buf), 
            txid: FfiConverterOptionString.read(from: buf), 
            blindedUtxo: FfiConverterOptionString.read(from: buf), 
            unblindedUtxo: FfiConverterOptionTypeOutpoint.read(from: buf), 
            changeUtxo: FfiConverterOptionTypeOutpoint.read(from: buf), 
            blindingSecret: FfiConverterOptionUInt64.read(from: buf), 
            expiration: FfiConverterOptionInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Transfer, into buf: Writer) {
        FfiConverterInt64.write(value.idx, into: buf)
        FfiConverterInt64.write(value.createdAt, into: buf)
        FfiConverterInt64.write(value.updatedAt, into: buf)
        FfiConverterTypeTransferStatus.write(value.status, into: buf)
        FfiConverterUInt64.write(value.received, into: buf)
        FfiConverterUInt64.write(value.sent, into: buf)
        FfiConverterOptionString.write(value.txid, into: buf)
        FfiConverterOptionString.write(value.blindedUtxo, into: buf)
        FfiConverterOptionTypeOutpoint.write(value.unblindedUtxo, into: buf)
        FfiConverterOptionTypeOutpoint.write(value.changeUtxo, into: buf)
        FfiConverterOptionUInt64.write(value.blindingSecret, into: buf)
        FfiConverterOptionInt64.write(value.expiration, into: buf)
    }
}


public struct Unspent {
    public var utxo: Utxo
    public var rgbAllocations: [RgbAllocation]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(utxo: Utxo, rgbAllocations: [RgbAllocation]) {
        self.utxo = utxo
        self.rgbAllocations = rgbAllocations
    }
}


extension Unspent: Equatable, Hashable {
    public static func ==(lhs: Unspent, rhs: Unspent) -> Bool {
        if lhs.utxo != rhs.utxo {
            return false
        }
        if lhs.rgbAllocations != rhs.rgbAllocations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(utxo)
        hasher.combine(rgbAllocations)
    }
}


fileprivate struct FfiConverterTypeUnspent: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Unspent {
        return try Unspent(
            utxo: FfiConverterTypeUtxo.read(from: buf), 
            rgbAllocations: FfiConverterSequenceTypeRgbAllocation.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Unspent, into buf: Writer) {
        FfiConverterTypeUtxo.write(value.utxo, into: buf)
        FfiConverterSequenceTypeRgbAllocation.write(value.rgbAllocations, into: buf)
    }
}


public struct Utxo {
    public var outpoint: Outpoint
    public var btcAmount: UInt64
    public var colorable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outpoint: Outpoint, btcAmount: UInt64, colorable: Bool) {
        self.outpoint = outpoint
        self.btcAmount = btcAmount
        self.colorable = colorable
    }
}


extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.outpoint != rhs.outpoint {
            return false
        }
        if lhs.btcAmount != rhs.btcAmount {
            return false
        }
        if lhs.colorable != rhs.colorable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(outpoint)
        hasher.combine(btcAmount)
        hasher.combine(colorable)
    }
}


fileprivate struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Utxo {
        return try Utxo(
            outpoint: FfiConverterTypeOutpoint.read(from: buf), 
            btcAmount: FfiConverterUInt64.read(from: buf), 
            colorable: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Utxo, into buf: Writer) {
        FfiConverterTypeOutpoint.write(value.outpoint, into: buf)
        FfiConverterUInt64.write(value.btcAmount, into: buf)
        FfiConverterBool.write(value.colorable, into: buf)
    }
}


public struct WalletData {
    public var dataDir: String
    public var bitcoinNetwork: BitcoinNetwork
    public var databaseType: DatabaseType
    public var pubkey: String
    public var mnemonic: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(dataDir: String, bitcoinNetwork: BitcoinNetwork, databaseType: DatabaseType, pubkey: String, mnemonic: String?) {
        self.dataDir = dataDir
        self.bitcoinNetwork = bitcoinNetwork
        self.databaseType = databaseType
        self.pubkey = pubkey
        self.mnemonic = mnemonic
    }
}


extension WalletData: Equatable, Hashable {
    public static func ==(lhs: WalletData, rhs: WalletData) -> Bool {
        if lhs.dataDir != rhs.dataDir {
            return false
        }
        if lhs.bitcoinNetwork != rhs.bitcoinNetwork {
            return false
        }
        if lhs.databaseType != rhs.databaseType {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(dataDir)
        hasher.combine(bitcoinNetwork)
        hasher.combine(databaseType)
        hasher.combine(pubkey)
        hasher.combine(mnemonic)
    }
}


fileprivate struct FfiConverterTypeWalletData: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> WalletData {
        return try WalletData(
            dataDir: FfiConverterString.read(from: buf), 
            bitcoinNetwork: FfiConverterTypeBitcoinNetwork.read(from: buf), 
            databaseType: FfiConverterTypeDatabaseType.read(from: buf), 
            pubkey: FfiConverterString.read(from: buf), 
            mnemonic: FfiConverterOptionString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: WalletData, into buf: Writer) {
        FfiConverterString.write(value.dataDir, into: buf)
        FfiConverterTypeBitcoinNetwork.write(value.bitcoinNetwork, into: buf)
        FfiConverterTypeDatabaseType.write(value.databaseType, into: buf)
        FfiConverterString.write(value.pubkey, into: buf)
        FfiConverterOptionString.write(value.mnemonic, into: buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BitcoinNetwork {
    
    case mainnet
    case testnet
    case signet
    case regtest
}

fileprivate struct FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork

    static func read(from buf: Reader) throws -> BitcoinNetwork {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: BitcoinNetwork, into buf: Writer) {
        switch value {
        
        
        case .mainnet:
            buf.writeInt(Int32(1))
        
        
        case .testnet:
            buf.writeInt(Int32(2))
        
        
        case .signet:
            buf.writeInt(Int32(3))
        
        
        case .regtest:
            buf.writeInt(Int32(4))
        
        }
    }
}


extension BitcoinNetwork: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DatabaseType {
    
    case sqlite
}

fileprivate struct FfiConverterTypeDatabaseType: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseType

    static func read(from buf: Reader) throws -> DatabaseType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .sqlite
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: DatabaseType, into buf: Writer) {
        switch value {
        
        
        case .sqlite:
            buf.writeInt(Int32(1))
        
        }
    }
}


extension DatabaseType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransferStatus {
    
    case waitingCounterparty
    case waitingConfirmations
    case settled
    case failed
}

fileprivate struct FfiConverterTypeTransferStatus: FfiConverterRustBuffer {
    typealias SwiftType = TransferStatus

    static func read(from buf: Reader) throws -> TransferStatus {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .waitingCounterparty
        
        case 2: return .waitingConfirmations
        
        case 3: return .settled
        
        case 4: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: TransferStatus, into buf: Writer) {
        switch value {
        
        
        case .waitingCounterparty:
            buf.writeInt(Int32(1))
        
        
        case .waitingConfirmations:
            buf.writeInt(Int32(2))
        
        
        case .settled:
            buf.writeInt(Int32(3))
        
        
        case .failed:
            buf.writeInt(Int32(4))
        
        }
    }
}


extension TransferStatus: Equatable, Hashable {}



public enum RgbLibError {

    
    
    // Simple error enums only carry a message
    case AllocationsAlreadyAvailable(message: String)
    
    // Simple error enums only carry a message
    case AssetNotFound(message: String)
    
    // Simple error enums only carry a message
    case BlindedUtxoAlreadyUsed(message: String)
    
    // Simple error enums only carry a message
    case CannotChangeOnline(message: String)
    
    // Simple error enums only carry a message
    case CannotDeleteTransfer(message: String)
    
    // Simple error enums only carry a message
    case CannotFailTransfer(message: String)
    
    // Simple error enums only carry a message
    case ConsignmentProxy(message: String)
    
    // Simple error enums only carry a message
    case Electrum(message: String)
    
    // Simple error enums only carry a message
    case FailedBdkSync(message: String)
    
    // Simple error enums only carry a message
    case FailedBroadcast(message: String)
    
    // Simple error enums only carry a message
    case FailedIssuance(message: String)
    
    // Simple error enums only carry a message
    case Io(message: String)
    
    // Simple error enums only carry a message
    case Inconsistency(message: String)
    
    // Simple error enums only carry a message
    case InexistentDataDir(message: String)
    
    // Simple error enums only carry a message
    case InsufficientAllocationSlots(message: String)
    
    // Simple error enums only carry a message
    case InsufficientAssets(message: String)
    
    // Simple error enums only carry a message
    case InsufficientFunds(message: String)
    
    // Simple error enums only carry a message
    case Internal(message: String)
    
    // Simple error enums only carry a message
    case InvalidAddress(message: String)
    
    // Simple error enums only carry a message
    case InvalidBitcoinKeys(message: String)
    
    // Simple error enums only carry a message
    case InvalidBlindedUtxo(message: String)
    
    // Simple error enums only carry a message
    case InvalidElectrum(message: String)
    
    // Simple error enums only carry a message
    case InvalidMnemonic(message: String)
    
    // Simple error enums only carry a message
    case InvalidName(message: String)
    
    // Simple error enums only carry a message
    case InvalidOnline(message: String)
    
    // Simple error enums only carry a message
    case InvalidPsbt(message: String)
    
    // Simple error enums only carry a message
    case InvalidPubkey(message: String)
    
    // Simple error enums only carry a message
    case InvalidTicker(message: String)
    
    // Simple error enums only carry a message
    case TransferNotFound(message: String)
    
    // Simple error enums only carry a message
    case WatchOnly(message: String)
    
}

fileprivate struct FfiConverterTypeRgbLibError: FfiConverterRustBuffer {
    typealias SwiftType = RgbLibError

    static func read(from buf: Reader) throws -> RgbLibError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .AllocationsAlreadyAvailable(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .AssetNotFound(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .BlindedUtxoAlreadyUsed(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 4: return .CannotChangeOnline(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 5: return .CannotDeleteTransfer(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 6: return .CannotFailTransfer(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 7: return .ConsignmentProxy(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 8: return .Electrum(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 9: return .FailedBdkSync(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 10: return .FailedBroadcast(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 11: return .FailedIssuance(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 12: return .Io(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 13: return .Inconsistency(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 14: return .InexistentDataDir(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 15: return .InsufficientAllocationSlots(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 16: return .InsufficientAssets(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 17: return .InsufficientFunds(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 18: return .Internal(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 19: return .InvalidAddress(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 20: return .InvalidBitcoinKeys(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 21: return .InvalidBlindedUtxo(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 22: return .InvalidElectrum(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 23: return .InvalidMnemonic(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 24: return .InvalidName(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 25: return .InvalidOnline(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 26: return .InvalidPsbt(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 27: return .InvalidPubkey(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 28: return .InvalidTicker(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 29: return .TransferNotFound(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 30: return .WatchOnly(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: RgbLibError, into buf: Writer) {
        switch value {

        

        
        case let .AllocationsAlreadyAvailable(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .AssetNotFound(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .BlindedUtxoAlreadyUsed(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)
        case let .CannotChangeOnline(message):
            buf.writeInt(Int32(4))
            FfiConverterString.write(message, into: buf)
        case let .CannotDeleteTransfer(message):
            buf.writeInt(Int32(5))
            FfiConverterString.write(message, into: buf)
        case let .CannotFailTransfer(message):
            buf.writeInt(Int32(6))
            FfiConverterString.write(message, into: buf)
        case let .ConsignmentProxy(message):
            buf.writeInt(Int32(7))
            FfiConverterString.write(message, into: buf)
        case let .Electrum(message):
            buf.writeInt(Int32(8))
            FfiConverterString.write(message, into: buf)
        case let .FailedBdkSync(message):
            buf.writeInt(Int32(9))
            FfiConverterString.write(message, into: buf)
        case let .FailedBroadcast(message):
            buf.writeInt(Int32(10))
            FfiConverterString.write(message, into: buf)
        case let .FailedIssuance(message):
            buf.writeInt(Int32(11))
            FfiConverterString.write(message, into: buf)
        case let .Io(message):
            buf.writeInt(Int32(12))
            FfiConverterString.write(message, into: buf)
        case let .Inconsistency(message):
            buf.writeInt(Int32(13))
            FfiConverterString.write(message, into: buf)
        case let .InexistentDataDir(message):
            buf.writeInt(Int32(14))
            FfiConverterString.write(message, into: buf)
        case let .InsufficientAllocationSlots(message):
            buf.writeInt(Int32(15))
            FfiConverterString.write(message, into: buf)
        case let .InsufficientAssets(message):
            buf.writeInt(Int32(16))
            FfiConverterString.write(message, into: buf)
        case let .InsufficientFunds(message):
            buf.writeInt(Int32(17))
            FfiConverterString.write(message, into: buf)
        case let .Internal(message):
            buf.writeInt(Int32(18))
            FfiConverterString.write(message, into: buf)
        case let .InvalidAddress(message):
            buf.writeInt(Int32(19))
            FfiConverterString.write(message, into: buf)
        case let .InvalidBitcoinKeys(message):
            buf.writeInt(Int32(20))
            FfiConverterString.write(message, into: buf)
        case let .InvalidBlindedUtxo(message):
            buf.writeInt(Int32(21))
            FfiConverterString.write(message, into: buf)
        case let .InvalidElectrum(message):
            buf.writeInt(Int32(22))
            FfiConverterString.write(message, into: buf)
        case let .InvalidMnemonic(message):
            buf.writeInt(Int32(23))
            FfiConverterString.write(message, into: buf)
        case let .InvalidName(message):
            buf.writeInt(Int32(24))
            FfiConverterString.write(message, into: buf)
        case let .InvalidOnline(message):
            buf.writeInt(Int32(25))
            FfiConverterString.write(message, into: buf)
        case let .InvalidPsbt(message):
            buf.writeInt(Int32(26))
            FfiConverterString.write(message, into: buf)
        case let .InvalidPubkey(message):
            buf.writeInt(Int32(27))
            FfiConverterString.write(message, into: buf)
        case let .InvalidTicker(message):
            buf.writeInt(Int32(28))
            FfiConverterString.write(message, into: buf)
        case let .TransferNotFound(message):
            buf.writeInt(Int32(29))
            FfiConverterString.write(message, into: buf)
        case let .WatchOnly(message):
            buf.writeInt(Int32(30))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension RgbLibError: Equatable, Hashable {}

extension RgbLibError: Error { }

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterUInt32.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterUInt64.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterInt64.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutpoint: FfiConverterRustBuffer {
    typealias SwiftType = Outpoint?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeOutpoint.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutpoint.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeAsset: FfiConverterRustBuffer {
    typealias SwiftType = [Asset]

    static func write(_ value: [Asset], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeAsset.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Asset] {
        let len: Int32 = try buf.readInt()
        var seq = [Asset]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAsset.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRgbAllocation: FfiConverterRustBuffer {
    typealias SwiftType = [RgbAllocation]

    static func write(_ value: [RgbAllocation], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeRgbAllocation.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [RgbAllocation] {
        let len: Int32 = try buf.readInt()
        var seq = [RgbAllocation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRgbAllocation.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [Transfer]

    static func write(_ value: [Transfer], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeTransfer.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Transfer] {
        let len: Int32 = try buf.readInt()
        var seq = [Transfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransfer.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUnspent: FfiConverterRustBuffer {
    typealias SwiftType = [Unspent]

    static func write(_ value: [Unspent], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeUnspent.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [Unspent] {
        let len: Int32 = try buf.readInt()
        var seq = [Unspent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnspent.read(from: buf))
        }
        return seq
    }
}

public func generateKeys(bitcoinNetwork: BitcoinNetwork)  -> Keys {
    return try! FfiConverterTypeKeys.lift(
        try!
    
    rustCall() {
    
    rgb_lib_53a0_generate_keys(
        FfiConverterTypeBitcoinNetwork.lower(bitcoinNetwork), $0)
}
    )
}



public func restoreKeys(bitcoinNetwork: BitcoinNetwork, mnemonic: String) throws -> Keys {
    return try FfiConverterTypeKeys.lift(
        try
    
    rustCallWithError(FfiConverterTypeRgbLibError.self) {
    
    rgb_lib_53a0_restore_keys(
        FfiConverterTypeBitcoinNetwork.lower(bitcoinNetwork), 
        FfiConverterString.lower(mnemonic), $0)
}
    )
}



/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum RgbLibLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}